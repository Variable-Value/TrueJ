package tlang;

import java.util.Map;
import java.util.Optional;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import tlang.KnowledgeBase.ProofResult;
import tlang.Scope.VarInfo;
import tlang.TLantlrParser.*;

import static tlang.TUtil.*;
import static tlang.KnowledgeBase.*;

/** Check all constraints for consistency and check that all deductions are supported. This is the
 * final pass before the compiler generates Java code. Eventually, the proof pass will be rather
 * complicated, including correctness of initialization of the static object, correctness of the
 * static methods, correctness of instance initialization, including all constructors, and
 * correctness of all methods.
 *
 * There are 4 passes:
 * <ol>
 * <li>Collect all field types and static field values, which was done in the FieldVisitor class
 * <li>Check static validity, including static initialization blocks, passing the static object
 * KnowledgeBase to the following proof step.
 * <li>Collect instance field initializers and initialization blocks, passing the instance
 * initialization KnowledgeBase for constructors, and also the instance object KnowledgeBase for
 * methods, to the following proof step.
 * <li>Prove instance validity, including both methods and constructors.
 * </ol>
 * <p>
 * References like (Deransart, et al., p.236) refer to
 * <p>
 * <cite>Prolog: The Standard:Reference Manual</cite>, P. Deransart, A. Ed-Dbali, L. Cervoni,
 * Springer-Verlog, 1996.
 * <p>
 * TODO: All class fields must be non-null by the end of a constructor unless they were declared
 * with the <code>optional</code> modifier. */
class TLantlrProofVisitor extends RewriteVisitor {

private static final String prover = "Prover";
/* TODO: remove the following CollectingMsgListener from the knowledgeBase and have the calling
 * program decide what to do. */

/** The list of the program's errors generated by the compiler. Here it is used to report to the
 * users a failure in an attempt to prove a statement. */
private CollectingMsgListener errors;

private static char prologDecoratorChar = '^';
private static RewriteVisitor latestProofVisitor;

/** Contains a logical representation of the state of a program. A child KnowledgeBase is created
 * for each scope in which something might need to be proven. */
private KnowledgeBase kb = new KnowledgeBase();


public TLantlrProofVisitor(
  TokenStream tokenStream,
  Map<RuleContext, Scope> ctxToScope,
  CollectingMsgListener errors)
{
  super(tokenStream, ctxToScope);
  this.errors = errors;
}

/** All <code>axiom, constraint, conjecture,</code> and <code>given</code> statements must be
 * consistent and, with the code, must support the <code>theorem, lemma,</code> and
 * <code>means</code> statements.
 *
 * @param  parseTree   of the code to be proven
 * @param  tokenStream that was used to generate the parseTree
 * @param  ctxToScope  map from a parse context to all scope information, especially variables
 * @param  errors      collects all error messages
 * @return             a record of the prolog calls that were made to the prover
 */
public static String proveCorrectness( ParseTree               parseTree,
                                       TokenStream             tokenStream,
                                       Map<RuleContext, Scope> ctxToScope,
                                       CollectingMsgListener   errors
                                     )
{
  latestProofVisitor = new TLantlrProofVisitor(tokenStream, ctxToScope, errors);
  latestProofVisitor.visit(parseTree);
  String textSentToProver = notNull(latestProofVisitor.rewriter.getText());
  return textSentToProver;
}




//***** Visit the Nodes that call the prover and rewrite the code into Prolog *******


/** Override the visit to this node in order to put all the calls to visit varieties of value-name
 * decoration into the same class and near one another.
 * @param  ctx The parse tree, which is the single, leaf, node for the undecorated value name that
 *               contains the value-name token.
 */
@Override
public
        Void visitT_UndecoratedIdentifier(T_UndecoratedIdentifierContext ctx)
{
  return VOIDNULL;
}

/** Translate a pre-decorated value name to its Prolog form and substitute it in place. The
 * character <code>^</code> is substituted for the decorator, a scope name is prefixed using a dot
 * separator, and the whole name is enclosed in single quotes. For example, <code>'xyx</code> is
 * transformed to <code>'^xyz'</code> and if the variable <code>xyz</code> is an instance field, the
 * final transformation will be <code>'this.^xyz'</code>. Value names for local variables that are
 * at the top level of an executable component, e.g., a method, are not prefixed with a scope.
 * @param  valueNameCtx The parse tree, which is the single, leaf, node for the pre-decorated value
 *                        name that contains the value-name token.
 */
@Override
public Void visitT_PreValueName(T_PreValueNameContext valueNameCtx) {
  final String variableName = rewriter.source(valueNameCtx).substring(1); // e.g., 'xxx -> xxx
  final String scopePrefix = getScopePrefix(variableName);
  final String prologName = "'" + scopePrefix + "^" + variableName + "'"; // e.g., 'this.^xxx'
  rewriter.substituteText(valueNameCtx, prologName);
  return VOIDNULL;
}

/**
 * Translate a mid-decorated value name to its Prolog form and substitute it in place. The character
 * <code>^</code> is substituted for the decorator, a scope name is prefixed, followed by a dot
 * separator, and the whole name is enclosed in single quotes. For example, <code>abc'xyx</code> is
 * transformed to <code>'abc^xyz'</code> and if the variable <code>abc</code> is an instance field,
 * the final transformation will be <code>'this.abc^xyz'</code>. Value names for local variables
 * that are at the top level of an executable component, e.g., a method, are not prefixed with a
 * scope.
 *
 * @param valueNameCtx The parse tree's leaf node context for the mid-decorated value-name token.
 */
@Override
public Void visitT_MidValueName(T_MidValueNameContext valueNameCtx) {
  final String valueName = rewriter.source(valueNameCtx);         // example : varName'xxx
  final String[] n = valueName.split(decoratorString);                 // { varName,xxx }
  final String prologName = "'" + getScopePrefix(n[0]) + n[0] + "^" + n[1] + "'";
                        // 'this.varName^xxx'
  rewriter.substituteText(valueNameCtx, prologName);
  return VOIDNULL;
}

/** Translate a post-decorated value name to its Prolog form, in place. The character <code>^</code>
 * is substituted for the decorator, a scope name is prefixed using a dot separator, and the whole
 * name is enclosed in single quotes. For example, <code>abc'</code> is transformed to
 * <code>'abc^'</code> and if the variable <code>abc</code> is an instance field, the final
 * transformation will be <code>'this.abc^'</code>. Value names for local variables that are at the
 * top level of an executable component, e.g., a method, are not prefixed with a scope.
 * <p>
 * {@inheritDoc}
 * @param  valueNameCtx The parse tree, which is the single, leaf, node for the post-decorated value
 *                        name that contains the value-name token.
 */
@Override
public Void visitT_PostValueName(T_PostValueNameContext valueNameCtx) {
  final String valueName = rewriter.source(valueNameCtx);
  final String variableName = valueName.substring(0, valueName.length() - 1);
  rewriter.substituteText(valueNameCtx, "'" + getScopePrefix(variableName) + variableName + "^'");
    // "'" is part of the prolog name, not a decorator
  return VOIDNULL;
}

/** Translate a Java literal into the corresponding prover literal.
 * <p>
 * For the <code>FloatingPointLiteral</code>, change something like .25 to 0.25, with a leading
 * zero. (Deransart, et al., p.236)
 */
@Override
public Void visitT_literal(T_literalContext literalCtx) {
  visitChildren(literalCtx);

  TerminalNode terminalNode = literalCtx.FloatingPointLiteral();
  if (terminalNode != null) {
    String numericText = terminalNode.getText();
    if (numericText.startsWith("."))
      rewriter.substituteText(literalCtx, "0" + numericText);
  }
  // TODO: change 123E-4 to 0.0123 and .2E12 to 200000000000

  return VOIDNULL;
}

/** {@inheritDoc} */
@Override
public Void visitInitializedVariable(InitializedVariableContext ctx) {
  visitChildren(ctx);

  String translatedOp = needsEquivalenceForBooleanTarget(ctx) ? " === " : " = ";
  rewriter.replace(ctx.op, translatedOp);
  kb.assume(rewriter.source(ctx));
  return VOIDNULL;
}

/** Submit the assignment to the prover. TODO: provide the useful type information for the new value
 * name that is being created.
 * <p>
 * {@inheritDoc} */
@Override
public Void visitAssignStmt(AssignStmtContext ctx) {
  visitChildren(ctx);

  String src = transformAssignment(ctx);
  rewriter.substituteText(ctx, src);
  kb.assume(src);
  return VOIDNULL;
}

private String transformAssignment(AssignStmtContext ctx) {
  T_assignableContext lhs = ctx.t_assignment().t_assignable();
  String op = isBooleanIdentifier(lhs.t_identifier(), notNull(currentScope))
              ? "===" : " = ";
  T_expressionContext rhs = ctx.t_assignment().t_expression();
  String src = parenthesize(rewriter.source(lhs) + op + parenthesize(rewriter.source(rhs)));
  return src;
}

private boolean needsEquivalenceForBooleanTarget(InitializedVariableContext ctx) {
  var targetCtx = ctx.t_initializedVariableDeclaratorId().t_idDeclaration().t_identifier();
  return isBooleanIdentifier(targetCtx, notNull(currentScope));
}

/**
 * If there is a return value, allow the programmer to use either decorated or undecorated
 * value, e.g., <code>return'</code> or <code>return</code> in logic statements. This means that the
 * Context Checker must refuse the use of both.
 */
@Override public Void visitReturnStmt(TLantlrParser.ReturnStmtContext ctx) {
  visitChildren(ctx);

  String expression = ctx.t_expression().getText();
  String returnTranslation = ctx.t_expression().isEmpty() ? "true" : returnExpression(expression);
  rewriter.substituteText(ctx, returnTranslation);
  return VOIDNULL;
}

/**
 * Gives the predicate needed to equate the returned expression to the value name that represents
 * the returned value, which may be either <code>return'</code> or <code>return</code>
 *
 * Note that the single quote marks ' are not decorators, but enclose the prolog name, and the
 * decorator is the caret character ^.
 */
private String returnExpression(String returnedExpression) {
  String decoratedReturn = "'" + getScopePrefix("return") + "return^'";
  if (TCompiler.isFinalDecorationRequired())
    return    parenthesize(decoratedReturn +" = "+ returnedExpression);
  else
    return    parenthesize(decoratedReturn +" = "+ returnedExpression)
      + and + parenthesize(           "return = "+ returnedExpression);
}

@Override public Void visitEmptyStmt(TLantlrParser.EmptyStmtContext ctx) {
  rewriter.substituteText(ctx, "true");
  return VOIDNULL;
}

@Override public Void visitMultiplicativeExpr(TLantlrParser.MultiplicativeExprContext ctx) {
  visitChildren(ctx);

  rewriter.substituteText(ctx, parenthesize(rewriter.source(ctx)));
  return VOIDNULL;
}

@Override public Void visitAdditiveExpr(TLantlrParser.AdditiveExprContext ctx) {
  visitChildren(ctx);

  rewriter.substituteText(ctx, parenthesize(rewriter.source(ctx)));
  return VOIDNULL;
}



/**
 * A method declaration has a background scope for a parent in order to hold all
 * the higher scope fields.
 */
@Override public Void visitT_methodDeclaration(T_methodDeclarationContext ctx) {
  withChildOfKb( () -> {super.visitT_methodDeclaration(ctx);} );
  return VOIDNULL;
}

/** Translate a block of statements into the meaning of its statements, changing the surrounding
 * braces to parentheses. Loop from the bottom up, stopping with the latest means-statement that was
 * issued, which summarizes everything needed from the code above it in this block. */
/* TODO: Progress from the top down. Every status statement will need to be proven. At each
 * means-statement, discard the preceeding statements, but keep variable type info. */
/* TODO: after the means-statement is encountered, keep looking for variable declarations to collect
 * type information for all valueNames that occur in the meaningful code. */
@Override public Void visitT_block(T_blockContext ctx) {
  withChildOfKb(() ->
    withChildScopeForCtx(ctx, () -> visitChildren(ctx))
  );
  boolean statementsAreActive = true; // so far
  String types = "true";
  String meaning = "true";
  for (int i = ctx.t_blockStatement().size()-1; i >= 0; i-- ) {
    T_blockStatementContext bStCtx = ctx.t_blockStatement(i);
    T_statementContext statement = bStCtx.t_statement();
    if (statement != null) {
      if (statementsAreActive) {
        if (statement instanceof MeansStmtContext meansCtx) {
          statementsAreActive = false;
          meaning += and + rewriter.source(meansCtx.t_means().t_expression());
        } else if (statement instanceof LemmaStmtContext lemmaCtx) {
          meaning += and + rewriter.source(lemmaCtx.t_lemma().t_expression());
        } else {
          meaning += and + rewriter.source(statement);
        }
      }
    } else {
      T_localVariableDeclarationContext localDeclaration = bStCtx.t_localVariableDeclaration();
      if (localDeclaration != null) {
        String type = localDeclaration.t_type().getText();
        for (T_variableDeclaratorContext declarator : localDeclaration.t_variableDeclarator()) {
          if (declarator instanceof UninitializedVariableContext) {
            var uninitStatement = (UninitializedVariableContext)declarator;
            String valueName = rewriter.source(uninitStatement.t_uninitializedVariableDeclaratorId());
            types += and + " type("+ type +","+ valueName +")";
          } else { // initialization instanceof InitializedVariableContext
            InitializedVariableContext initStatement = (InitializedVariableContext)declarator;
            String valueName = rewriter.source(initStatement.t_initializedVariableDeclaratorId());
            types += and + " type("+ type +","+ valueName +")";
            if (statementsAreActive)
              meaning += and + parenthesize(rewriter.source(initStatement));
          }
        }
      } else {
        T_typeDeclarationContext localType = bStCtx.t_typeDeclaration();
        //if (localType != null) // localType cannot be null because of syntax
        // TODO: After programming type definition, make sure that local type definition works, too.
        //if (statementsAreActive) {
        //  meaning += and + ....
        //}
      }
    }
  }

  rewriter.substituteText(ctx, meaning);
  kb.assume(meaning);

  return VOIDNULL;
}

@Override public Void visitWhileStmt(WhileStmtContext ctx) {
  LoopMgr.validateWhile(ctx, this);
  visitChildren(ctx);

  String condition = rewriter.source(ctx.t_condition());
  String invariant = parenthesize(rewriter.source(ctx.t_endingInvariant()));
  rewriter.substituteText(ctx, parenthesize(condition + and + invariant ));
  return VOIDNULL;
}


/** Translate if-statement to logic. */
@Override
public Void visitIfStmt(IfStmtContext ctx) {
  String condition = translateCondition(ctx.t_parExpression());
  String thenMeaning = checkBranch(condition, ctx.t_statement(0));

  String elseMeaning = "";
  T_statementContext elseContext = ctx.t_statement(1);
  if (elseContext == null)
    elseMeaning = negate(condition);
  else
    elseMeaning = checkBranch(negate(condition), elseContext);

  rewriter.substituteText(ctx, parenthesize(thenMeaning + or + elseMeaning));
  kb.assume(rewriter.source(ctx));
  return VOIDNULL;
}

private String negate(String condition) {
  return parenthesize(not + condition);
}

private String translateCondition(T_parExpressionContext parenthesizedExpressionCtx) {
  visit(parenthesizedExpressionCtx);
  String condition = rewriter.source(parenthesizedExpressionCtx);
  return condition;
}

/** A branch is a scope, but since it is also a single statement, it doesn't require the
 * paraphernalia that a scope normally requires. */
private String checkBranch(String condition, T_statementContext branchCtx) {
  withChildOfKb(() -> {
    kb.assume(condition);
    visit(branchCtx);
  });
  return parenthesize(condition + and + rewriter.source(branchCtx));
}

@Override public Void visitT_expression(TLantlrParser.T_expressionContext ctx) {
  visitChildren(ctx);

  //TODO do we need this:  rewriter.substituteText(ctx, parenthesize(rewriter.source(ctx)));
  return VOIDNULL;
}


/** Translate <code>!</code> to the provers negation <code>-</code> */
@Override
public Void visitNotExpr(NotExprContext ctx) {
  visitChildren(ctx);

  rewriter.replace(ctx.start, "-");
  return VOIDNULL;
}

/** Parenthesize the relational expression and translate the operators to appropriate prover
 * operators. */
@Override
public Void visitConjRelationExpr(TLantlrParser.ConjRelationExprContext ctx) {
  visitChildren(ctx);

  translateOps(ctx);
  rewriter.substituteText(ctx, parenthesize(rewriter.source(ctx)));
  return VOIDNULL;
}

//@formatter:off
/**
 * Translate the operators to appropriate prover operators. If the expressions are boolean, use the
 * provers logical operators.
 *
 * <table>
 *   <tr><th>Java  <th>Prover
 *   <tr><td>&lt;  <td>&lt;
 *   <tr><td>&lt;= <td>=&lt;
 *   <tr><td>=     <td>=  (=== for boolean)
 *   <tr><td>!=    <td>#= (=#= for boolean)
 *   <tr><td>&gt;= <td>&gt;=
 *   <tr><td>&gt;  <td>&gt;
 * </table>
 */  //@formatter:on
private void translateOps(ConjRelationExprContext ctx) {
  String operator = ctx.op.getText();
  if ("<=".equals(operator))
    rewriter.replace(ctx.op, "=<");
  if ("=".equals(operator))
    rewriter.replace(ctx.op, hasBooleanTerms(ctx.t_expressionDetail(0), notNull(currentScope))
                                 ? "===" : " = ");
  if ("!=".equals(operator))
    rewriter.replace(ctx.op, hasBooleanTerms(ctx.t_expressionDetail(0), notNull(currentScope))
                                 ? "=#=" : "#=");
}

/** Replace the Java OR (|) with the prover OR (\/).
 * <p>
 * {@inheritDoc} */
@Override
public Void visitOrExpr(OrExprContext ctx) {
  visitChildren(ctx);

  rewriter.replace(binaryOperatorToken(ctx), or);
  return VOIDNULL;
}

/** Replace the Java AND (&) with the prover AND (/\).
 * <p>
 * {@inheritDoc} */
@Override
public Void visitAndExpr(AndExprContext ctx) {
  visitChildren(ctx);

  rewriter.replace(binaryOperatorToken(ctx), and);
  return VOIDNULL;
}

/** Replace the Java conditional OR (||) with the prover OR (\/).
 * <p>
 * {@inheritDoc} */
@Override
public Void visitConditionalOrExpr(ConditionalOrExprContext ctx) {
  visitChildren(ctx);

  rewriter.replace(binaryOperatorToken(ctx), or);
  return VOIDNULL;
}

/** Replace the Java conditional AND (&&) with the prover AND (/\).
 * <p>
 * {@inheritDoc} */
@Override
public Void visitConditionalAndExpr(ConditionalAndExprContext ctx) {
  visitChildren(ctx);

  rewriter.replace(binaryOperatorToken(ctx), and);
  return VOIDNULL;
}

private Token binaryOperatorToken(ParseTree pt) {
  return (Token)pt.getChild(1).getPayload();
}

/** The operators ===, ==>, and <== are the same as those used in the prover, but =!= must be
 * replaced with =#=. */
@Override
public Void visitConjunctiveBoolExpr(ConjunctiveBoolExprContext ctx) {
  visitChildren(ctx);

  if ("=!=".equals(ctx.op)) {
    rewriter.replace(ctx.op, "=#=");
  }
  /*TODO: Look for child conjunctive boolean expression and duplicate terms to simulate conjunctive
   * operators. See grammar for details but watch out for parentheses.
   */
  // rewriter.substituteText(ctx, "( "+rewriter.source(ctx)+" )");
  return VOIDNULL;
}


/** Translate the expression of the means-statement into the KnowledgeBase language and submit the
 * means statement to the {@link KnowledgeBase} for proof, then substitute the <code>means</code>
 * expression for all the preceding assumptions, preserving the type information for any value names
 * that occur in the <code>means</code> statement.
 */
@Override
public Void visitT_means(T_meansContext ctx) {
  visitChildren(ctx); // rewrite code into the KnowledgeBase language

  T_expressionDetailContext predicate = ctx.t_expression().t_expressionDetail();
  String meansStatementForProver = knowledgeBaseCode(predicate);

  ProofResult result = kb.substituteIfProven(meansStatementForProver);

  if ( result != ProofResult.provenTrue) {
    result = proveEachConjunct(predicate);
  }
  rewriter.substituteText(ctx.t_expression(), meansStatementForProver);
  return VOIDNULL;
}

/** Translate the expression of the lemma into the KnowledgeBase language and submit it
 * to the {@link KnowledgeBase} for proof, then append the <code>lemma</code>
 * expression to the preceding assumptions for use in following proofs.
 */
@Override
public Void visitT_lemma(T_lemmaContext ctx) {
  visitChildren(ctx); // rewrite code into the KnowledgeBase language

  T_expressionDetailContext predicate = ctx.t_expression().t_expressionDetail();
  String lemmaStatementForProver = knowledgeBaseCode(predicate);

  ProofResult result = kb.assumeIfProven(lemmaStatementForProver);

  if ( result != ProofResult.provenTrue) {
    result = proveEachConjunct(predicate);
  }
  rewriter.substituteText(ctx.t_expression(), lemmaStatementForProver);
  return VOIDNULL;
}

private ProofResult proveEachConjunct(T_expressionDetailContext conjunction) {
  conjunction = removeAnyParentheses(conjunction);
  if (isSingleConjunct(conjunction)) {
    ProofResult result = kb.assumeIfProven(knowledgeBaseCode(conjunction));
    reportAnyError(conjunction, result);
    return result;
  }

  for (ParseTree child : conjunction.children) {
    if (child instanceof T_expressionDetailContext) {
      T_expressionDetailContext expr = (T_expressionDetailContext)child;
      ProofResult conjunctResult = proveEachConjunct(expr);
      if (conjunctResult != ProofResult.provenTrue)
        return conjunctResult;
    }
  }
  return ProofResult.provenTrue;
}

private T_expressionDetailContext removeAnyParentheses(T_expressionDetailContext conjunction) {
  if ( ! (conjunction instanceof PrimaryExprContext))
    return conjunction;

  final var primary = ((PrimaryExprContext)conjunction).t_primary();
  final var parens = primary.t_parExpression();
  if (parens == null)
    return conjunction;

  T_expressionContext theExpression = parens.t_expression();
  final var innerExpression = theExpression.t_expressionDetail();
  return removeAnyParentheses(innerExpression);
}

private boolean isSingleConjunct(T_expressionDetailContext expressionDetail) {
  return !isConjunction(expressionDetail);
}

private boolean isConjunction(ParseTree expressionDetail) {
  return expressionDetail instanceof ConditionalAndExprContext
         || expressionDetail instanceof AndExprContext;
}

private void reportAnyError(ParserRuleContext ctx, ProofResult result) {
  if (result == ProofResult.provenTrue)
    return;

  String msg = null;
  if (result == ProofResult.unsupported)
    msg = "The code does not support the proof of the statement: " + rewriter.originalSource(ctx);
  else if (result == ProofResult.reachedLimit)
    msg = "The prover reached an internal limit. Consider adding a lemma to help prove "
          + "the statement: \n    " + rewriter.originalSource(ctx);
  errors.collectError(prover, ctx.getStart(), msg);
}

/**
 * Translate additional details to the knowledge-base language.
 */
private String knowledgeBaseCode(ParseTree node) {
  String translated = expandForall(rewriter.source(node));
  return translated.replaceAll("//", "%");
}

/** Search for variables that are bound by a <code>forall</code> statement and add the expanded type
 * information for the variables inside the scope of the <code>forall</code>, that is, inside the
 * quantified statement) so that it will be available for use in the proof. Conjoin the "useful"
 * type constraints at the beginning of the scope of the bound variable and the "deep" constraints
 * at the end of the scope of the bound variable.
 * @param  statement the statement to be proven from a status statement
 * @return           the modified statement */
private String expandForall(String statement) {
  // TODO Expand forall statements for KB by adding type information for each forall variable
  return statement;
}

/* ************************ Helper methods ************************************/

/** Parenthesize the string */
private String parenthesize(String expression) {
  return "(" + expression + ")";
}

/** Get the name of the scope with a following dot separator, ready for prefixing to a prolog
 * variable name. For instance, an object-instance field returns "this." and a local variable that
 * is declared at the top level of a method returns "".
 * @param  variableName
 * @return              scope name followed by a dot separator */
private String getScopePrefix(final String variableName) {
  final Optional<VarInfo> info = notNull(currentScope).getOptionalExistingVarInfo(variableName);
  return info.map(v -> v.getScopeWhereDeclared().getLabel() + ".")
             .orElse("");
}

/** The full type name will need to include the package where it is defined unless it is a
 * primitive, but for now we just return the type as given in the code.
 * @param  idType
 * @return */
private String typeFullName(String idType) {
  // TODO look up type in information from imports or package
  return idType;
}

/** Extract the full variable name, including any scope prefix, from the value name, keeping the
 * single quotes required for general Prolog atom names.
 *
 * @param  val The Prolog version of the value name, including single quotes and any scope prefix.
 * @return     The variable name constructed from the <code>val</code> */
private String varName(String val) {
  final int pos = val.indexOf(prologDecoratorChar);
  if (pos == -1)
    return val;                               // return 'abc' for 'abc'
  else if (pos == 1)
    return "'" + val.substring(2);            // return 'abc' for '^abc'
  else
    return val.substring(0, pos) + "'"; // return 'abc' for 'abc^' or 'abc^de'
}

/** Use the Java execution stack as an implicit stack for knowledgebases  */
private void withChildOfKb(Runnable acceptFunction) {
  KnowledgeBase parentKb = kb;
  kb = new KnowledgeBase(parentKb);  // create child kb
  acceptFunction.run();              // use child kb
  kb = parentKb;                     // restore parent kb
}

/**
 * Juggle the status of an object from @Nullable to @NonNull for an object that is known to be
 * non-null. The programmer must ensure that the object is guaranteed by other code to be non-null.
 * It is much safer to check for <code>null</code> and throw an exception if you made a mistake.
 * But if you are confident, using this is more elegant than a
 * <code>@SuppressWarnings("null")</code> on a whole method. Since this method is private and
 * doesn't do anything, it compiles away to almost nothing.
 */
@SuppressWarnings("null")
private static <T> @NonNull T notNull(@Nullable T item) {
  return (@NonNull T)item;
}

} // end class
