package tlang;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.TerminalNode;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import tlang.Scope.VarInfo;
import tlang.TLantlrParser.ConjRelationExprContext;
import tlang.TLantlrParser.T_expressionContext;

import static tlang.TCompiler.*;
import static tlang.TLantlrParser.*;
import static tlang.TUtil.*;

/** Visitor for syntactical context checking of parsed T programs, sometimes called a "semantic
 * check". Operates on a syntax oriented parse tree generated by Antlr. The ContextCheckVisitor also
 * generates a scopeMap that holds the scope object associated with each executable or block.
 * <p>
 * All the work is done when the constructor is invoked. First the FieldVisitor is invoked, then
 * the context checking begins.
 */
public class ContextCheckVisitor extends TLantlrBaseVisitor<Void> {

private static final String $T$ = TLantlrJavaRewriter.$T$;
private static final String invalidCharsMsg
      = $T$ +" is reserved for T language internal use only";

/**
 * Is Context in code with command statements? That is, are we in a method, constructor, or
 * initializer? Note that a field initialization is not considered to be an executable.
 */
private boolean isInExecutable = false;

/** Is Context in the construction of a name of a variable or value for
 * assignment, i.e., assignable (LHS) or method parameter
 */
private boolean isInAssignment = false;

/** Is Context in non-executable logic statement, e.g., constraint or means, but not conjecture */
private boolean isInLogic = false;

/** The values found in the current means statement */
private Set<String> newMeansStatementValues = new HashSet<>();
  private void refreshNewMeansValues() { newMeansStatementValues = new HashSet<>(); }

private boolean hasOutstandingFinalMeansInBlock = false;
private boolean isInFinalMeans = false;
private boolean isInMeans      = false;

/** Are we in executable code nested within a conditional statement, e.g., then-block or else-block
 * of an if-then-else? */
enum BranchState { InitialBranch, FollowingBranch, NotInsideConditionalStatement }
BranchState branchState = BranchState.NotInsideConditionalStatement;
private static final String contextCheck = "Context Check";
Map<RuleContext, Scope> scopeMap;
public Map<RuleContext, tlang.Scope> getScopeMap() { return scopeMap; }

CollectingMsgListener errs;
Scope currentScope = null;

//@formatter:off
private String packageName = ""; // null means default package

  public String getPackageName() { return packageName; }

private String topTypeName = ""; // "" means thisIsTheTopLevelType()
  public String getTopTypeName() { return topTypeName; }
  private boolean thisIsTheTopLevelType() { return topTypeName.equals(""); }

/**
 * In case a return value name is used more than once, we store the first one used here, then
 * insist that the following ones have the same decoration. Be sure to reset to empty "" at the
 * beginning of the Method. Will have one of the following values:
 * <ul><li>Without a decoration, e.g., <code>return</code>
 *     <li>With final decoration, e.g., <code>return'</code>
 *     <li>With an empty string to indicate that the final value has not been defined
 */
private String formerReturnDecoration = "";


//@formatter:on

public ContextCheckVisitor(ParseTree tree,
                           CollectingMsgListener msgListener,
                           Map<RuleContext, Scope> scopeMap )
{
  this.errs = msgListener;
  this.scopeMap = scopeMap;
  new FieldVisitor(contextCheck, errs, scopeMap).visit(tree);
}


public String getCompoundTypeName() {
  if (packageName.length() > 0 && topTypeName.length() > 0) {
    return packageName +"."+ topTypeName;
  } else {
    return topTypeName; // may be ""
  }
}

@SuppressWarnings("null")
@Override
public Void visitT_packageDeclaration(T_packageDeclarationContext ctx) {
  packageName = ctx.t_qualifiedName().getText();
  // return visitChildren(ctx); // no need to visit children
  return VOIDNULL;
}

@Override
public Void visitT_classDeclaration(T_classDeclarationContext ctx) {
  String className = checkedText(ctx.UndecoratedIdentifier());
  typeDeclarationVisit(className, ctx);
  return VOIDNULL;
}

@Override
public Void visitEnumDeclaration(EnumDeclarationContext ctx) {
  String enumName = asString(ctx.Identifier());
  typeDeclarationVisit(enumName, ctx);
  return VOIDNULL;
}

@Override
public Void visitT_interfaceDeclaration(T_interfaceDeclarationContext ctx) {
  String interfaceName = checkedText(ctx.UndecoratedIdentifier());
  typeDeclarationVisit(interfaceName, ctx);
  return VOIDNULL;
}

@Override
public Void visitAnnotationTypeDeclaration(AnnotationTypeDeclarationContext ctx) {
  String annotationName = asString(ctx.Identifier());
  if (thisIsTheTopLevelType())
    topTypeName = annotationName;

  // Do not visitChildren(ctx); We make no changes to an AnnotationType
  return VOIDNULL;
}

/** Check the Condition, then-block, and any else block for errors as separate executables, and
 * check that any varNames defined in one of the executable blocks is also defined in the other.
 * <p>
 * A then block at the top level code statements needs to record the new value names assigned. Any
 * else block then needs a fresh copy of that list to make sure it assigns exactly the same value
 * names. The reason it needs a fresh copy is because it checks off the value names assigned by
 * deleting them from the list. Note that an else if clause also needs a fresh copy of the list. */
@Override
public Void visitIfStmt(IfStmtContext ctx) {
  visitChildren(ctx.t_parExpression());

  BranchState holdBranchState = branchState;

  checkIfBranches(ctx);

  branchState = holdBranchState;
  return VOIDNULL;
}

private void checkIfBranches(IfStmtContext ctx) {
  InitialConditionalBranchScope thenScope = checkFirstBranch(ctx);
  if (ctx.t_statement(1) != null)
    checkFollowingBranch(ctx, thenScope);
  else
    issueMissingValueNameMessages(ctx, thenScope.getCloneOfDelegatedValueNames());
  thenScope.setCollectionsToEmpty();
}

private InitialConditionalBranchScope checkFirstBranch(IfStmtContext ctx) {
  BranchState holdBranchState = branchState;
  branchState = BranchState.InitialBranch;

  String clauseId = idWithLineCharacter("then", getStart(ctx.t_statement(0)));
  InitialConditionalBranchScope thenScope
      = new InitialConditionalBranchScope(clauseId, currentScope);

  Scope holdScope = currentScope;
  currentScope = thenScope;
  visitCodeScope(ctx.t_statement(0));
  currentScope = holdScope;

  thenScope.setEndingValueNames();

  branchState = holdBranchState;
  return thenScope;
}

private void checkFollowingBranch(
      IfStmtContext ctx,
      InitialConditionalBranchScope thenScope) {
  BranchState holdBranchState = branchState;
  branchState = BranchState.FollowingBranch;

  ParserRuleContext elseCtx = ctx.t_statement(1);
  thenScope.reestablishEnclosingScopeValues();
  String clauseId = idWithLineCharacter("else", getStart(elseCtx));
  FollowingConditionalBranchScope elseScope
        = new FollowingConditionalBranchScope(clauseId, thenScope.getParent(), thenScope);

  Scope holdScope = currentScope;
  currentScope = elseScope;
  visitCodeScope(elseCtx);
  currentScope = holdScope;

  issueMissingValueNameMessages(ctx, elseScope.getNestedValueNames());
  thenScope.captureConflictingEndingValueNames();
  /* We leave the current value names of the variables at their ending values for the (last)
   * following branch */

  branchState = holdBranchState;
  elseScope.setCollectionsToEmpty();
}

/** Issue error message for any names that were defined in the first branch and not also defined
 * in the following branch */
private void issueMissingValueNameMessages(IfStmtContext ctx, Set<String> undefinedNames) {
  for (String valueName : undefinedNames) {
    String msg = "The value name "+ valueName + " was not defined in the else-clause";
    errs.collectError(contextCheck, ctx.getStop(), msg);
  }
}

/**
 * Check for an already declared variable with the same name. The variable name, value name, and
 * line number have already been collected into the varInfo by the {@link FieldVisitor}.
 * <p>{@inheritDoc}
 */
@Override public Void visitUninitializedField(UninitializedFieldContext ctx) {
  final Token valueNameToken = getStart(ctx.t_idDeclaration());
  visitFieldDeclaration(valueNameToken);
  return visitContextChildren(ctx);
}

/** Check for incorrectly decorated value name or a field name that has already been used. The
 * variable name, value name, and line number have already been collected into the varInto by the
 * {@link FieldVisitor}.
 * <p>
 * {@inheritDoc} */
@Override
public Void visitInitializedField(InitializedFieldContext ctx) {
  visitFieldDeclaration(getStart(ctx.t_idDeclaration()));
  checkForConfusingRelationalExpression(ctx.t_variableInitializer().t_expression());
  return visitContextChildren(ctx);
}

private void visitFieldDeclaration(Token valueNameToken) {
  ensureFinalDecorationIsSet(valueNameToken);
  final String varName = variableName(valueNameToken);
  VarInfo varInfo = notNull(currentScope.varToInfoMap.get(varName));
  checkForCorrectDecorationOfDeclaration(valueNameToken, varInfo);
  checkForAlreadyDeclared(valueNameToken, varName, varInfo);
}

private void checkForCorrectDecorationOfDeclaration(final Token valueNameToken, VarInfo varInfo) {
  if (  isInitialDecorated(valueNameToken)
     || isDecoratedCorrectlyForFinal(valueNameToken)
     )
    return;

  if (isMidDecorated(valueNameToken))
    errs.collectError(contextCheck, valueNameToken,
                      "Variable declarations may not use middle decoration");
  else
    checkWrongFinalDecoration(valueNameToken);

  defineValueToMakeFollowingMessagesMoreUseful(valueNameToken, varInfo);
}

private static void ensureFinalDecorationIsSet(final Token valueNameToken) {
  if (isFinalDecorationOpen()) {
    if (isFinalDecorated(valueNameToken))
      requireFinalDecoration(valueNameToken);
    else if (isUndecorated(valueNameToken))
      prohibitFinalDecoration(valueNameToken);
  }
}

private void defineValueToMakeFollowingMessagesMoreUseful(Token valueNameToken, VarInfo varInfo) {
  String valueName = valueName(valueNameToken);
  String varName = variableName(valueName);
  varInfo.defineNewValue(decorator + varName, valueNameToken.getLine());
  currentScope.makeValueAvailable(valueName);
}

@Override
public Void visitT_ERROR(TLantlrParser.T_ERRORContext ctx) {
  Token firstToken = getStart(ctx);
  errs.collectError(contextCheck, firstToken
                    , "Invalid statement. Perhaps misspelled keyword.");
  return visitChildren(ctx);
}


private void checkForAlreadyDeclared(Token varOrValueNameToken, String varName, VarInfo varInfo) {
  final int lineOfExistingVar = varInfo.getLineWhereDeclared();
  if (lineOfExistingVar != varOrValueNameToken.getLine()) {
    String msg = String.format("The field %s was already declared at line %d",
        varName, lineOfExistingVar);
    errs.collectError(contextCheck, varOrValueNameToken, msg);
  }
}

//TODO: Will parameters be handled here or in executableVisit(id, ctx)?
@Override
public Void visitT_methodDeclaration(T_methodDeclarationContext ctx) {
  formerReturnDecoration = "";
  final Token methodNameToken = ctx.UndecoratedIdentifier().getSymbol();
  final String methodId = idWithLC("method", valueName(methodNameToken), methodNameToken);
  executableVisit(methodId, ctx);
  return VOIDNULL;
}

@Override
public Void visitT_initializer(T_initializerContext ctx) {
  final String initializerId = idWithLineCharacter("initializer", getStart(ctx));
  executableVisit(initializerId, ctx);
  return VOIDNULL;
}

//TODO: Will parameters be handled here or in executableVisit(id, ctx)?
@Override
public Void visitT_constructorDeclaration(T_constructorDeclarationContext ctx) {
  final String constructorId = idWithLineCharacter("constructor", ctx.UndecoratedIdentifier().getSymbol());
  executableVisit(constructorId, ctx);
  return VOIDNULL;
}

/** An identifier for a token constructed from the prependString, the line that the forToken is on,
 * and the position in the line for the first character of the forToken. For implementation reasons
 * the line number starts counting with one, but the character position in the line starts counting
 * with zero. Example: the identifier for the starting token of a block might be
 * <code>block-L24C4</code>. */
private String idWithLineCharacter(String prependString, Token forToken) {
  return idWithLC(prependString, "", forToken);
}

/** An identifier for a token constructed from the prependString, the line that the forToken is on,
 * the position in the line for the first character of the forToken, and an appendString. For
 * implementation reasons the line number starts counting with one, but the character position in
 * the line starts counting with zero. Example: the identifier for a method might be
 * <code>method-L24C12-toString</code>. */
private String idWithLC(String prependString, String appendString, Token forToken) {
  int line = forToken.getLine();
  int charPosition = forToken.getCharPositionInLine();
  return prependString + "-L" + line + "C" + charPosition + "-" + appendString;
}

/**
 * Visit the code contained in an executable, that is, a method, constructor, or initializer block.
 *
 * @param id                A unique name for the executable, for use in error messages
 * @param executableContext The parse tree for the executable
 */
/* IMPLEMENTATION: When checking each executable, we create a BackgroundScope object with a copy of
 * the object's field information in order to preserve a clean copy of the object-level
 * information. */
private void executableVisit(String id, ParserRuleContext executableContext) {
  final Scope grandParent = currentScope; // push
  BackgroundScope backgroundParent = new BackgroundScope("background-" + id, grandParent);
  currentScope = new Scope(id, backgroundParent);

  visitCodeScope(executableContext);

  backgroundParent.clearForCodeGeneration();
  currentScope = grandParent; // pop
}

//TODO: vist children of method block with one scope, but BackgroundScope for surounding code
/**
 * Perform tasks common to all new executable scopes.
 * @param ctx         The parse context for the executable scope that is visited
 */
private void visitCodeScope(ParserRuleContext ctx) {
  scopeMap.put(ctx, currentScope);
  boolean enclosingIsInExecutable = isInExecutable;
  isInExecutable = true;

  visitChildren(ctx);

  currentScope.makeNewValueNamesAvailableToParent();
  isInExecutable = enclosingIsInExecutable;
  currentScope.clearForCodeGeneration();
}

@Override
public Void visitT_block(T_blockContext ctx) {
  Scope parent = currentScope;
  currentScope = createScopeForBlock(ctx, parent); //push

  visitChildren(ctx);

  currentScope.makeNewValueNamesAvailableToParent();

  hasOutstandingFinalMeansInBlock = false;
  currentScope.clearForCodeGeneration();
  currentScope = parent;  //pop
  return VOIDNULL;
}

private Scope createScopeForBlock(T_blockContext ctx, Scope parentScope) {
  final Token firstToken = getStart(ctx);
  String blockLabel = "block_L" + firstToken.getLine() + "C" + firstToken.getCharPositionInLine();
  currentScope = new Scope(blockLabel, parentScope);
  scopeMap.put(ctx, currentScope);
  return currentScope;
}

@Override
public Void visitT_blockStatement(T_blockStatementContext ctx) {
  if (hasOutstandingFinalMeansInBlock) {
    errs.collectError(contextCheck, getStart(ctx), "All statements must come before the final means");
    hasOutstandingFinalMeansInBlock = false;
      // to avoid cluttering with error message on any following statements of this block
  }

  visitChildren(ctx);
  return VOIDNULL;
}

@Override
public Void visitAssignStmt(AssignStmtContext ctx) {
  /* we reverse the order of visiting the children because assignment happens after the expression
   * is evaluated. This is important because we don't want to change the current value in the
   * variable info until the end of the assignment. */
  visit(ctx.t_expression());
  visit(ctx.t_assignable());

  checkForConfusingRelationalExpression(ctx.t_expression());
  return VOIDNULL;
}

/**
 * Is the right-hand expression of an assignment a conjunctive relational expression,
 * like <code>a < b</code> or <code>a = b = c</code>, tempting the
 * programmer to misread the assignment <code>=</code> as an equality in a chain of relations?
 * If so issue an error message.
 */
private void checkForConfusingRelationalExpression(T_expressionContext expression) {
  if ((expression.t_expressionDetail() instanceof ConjRelationExprContext))
    errs.collectError(contextCheck, getStart(expression)
                     ,   "The right-hand side must be parenthesized "
                       + "to keep the assignment from looking like "
                       + "part of a conjunctive relational expression"
                     );
}

/** Translate the expression that names the value that is being calculated, e.g., the right-hand
 * side value name in an assignment.  */
@Override
public Void visitT_assignable(T_assignableContext ctx) {
  final boolean oldInAssignment = isInAssignment;
  isInAssignment = true;

  visitChildren(ctx);

  isInAssignment = oldInAssignment;
  return VOIDNULL;
}

@Override
public Void visitT_initializedVariableDeclaratorId(T_initializedVariableDeclaratorIdContext ctx) {
  T_idDeclarationContext declCtx = ctx.t_idDeclaration();
  String idType = declCtx.idType;
  Token valToken = getStart(declCtx);
  checkDeclaredVariable(idType, valToken);
//  if (isSwitchSetForFinalDecoration() && isUndecorated(valToken)) {
//    errs.collectError(contextCheck, valToken,
//        "This name must be decorated because of the command line option -decorateFinal");
//  }
//  String valueName = ensureValidValueName(valToken);
//  String varName = variableName(valueName);
//  var newVarInfo = currentScope.declareNewVariable(valToken, declCtx.idType, varName, valueName);
//  if (newVarInfo.isEmpty()) {
//    recoverFromRedeclaredVariable(valToken);
//  }
//  currentScope.makeValueAvailable(valueName);
  return VOIDNULL;
}

@Override
public Void
visitT_uninitializedVariableDeclaratorId(T_uninitializedVariableDeclaratorIdContext ctx) {
  T_idDeclarationContext declCtx = ctx.t_idDeclaration();
  String idType = declCtx.idType;
  Token valToken = getStart(declCtx);
  checkDeclaredVariable(idType, valToken);
  return VOIDNULL;
}
private void checkDeclaredVariable(String idType, Token valToken) {
  checkFinalDecorationSwitch(valToken);
  String valueName = ensureValidValueName(valToken);
  String varName = variableName(valueName);
  var newVarInfo = currentScope.declareNewVariable(valToken, idType, varName, valueName);
  if (newVarInfo.isEmpty())
    recoverFromRedeclaredVariable(valToken);
  currentScope.makeValueAvailable(valueName);
}
private boolean checkFinalDecorationSwitch(Token valToken) {
  if (isSwitchSetForFinalDecoration() & isUndecorated(valToken)) {
    errs.collectError( contextCheck, valToken,
        "This name must be decorated because of the command line option -decorateFinal");
    return true;
  } else {
    return false;
  }
}

/** Issue error message, but then treat this as though it were a new value name in hopes of finding
 * more useful errors */
private void recoverFromRedeclaredVariable(final Token valueNameToken) {
  String valueName = valueName(valueNameToken);
  String varName = variableName(valueName);
  VarInfo existingVarInfo = currentScope.getConflictingVarDeclarationInfo(varName);
  String msg = "Attempted to declare variable "+ varName
              +", but it was already declared at line "+  existingVarInfo.getLineWhereDeclared();
  errs.collectError(contextCheck, valueNameToken, msg);
  defineTheValueNameRegardlessOfErrors(valueNameToken, existingVarInfo);
}

private String ensureValidValueName(Token valueNameToken) {
  String valueName = valueName(valueNameToken);
  if (isInitialDecorated(valueNameToken) || isDecoratedCorrectlyForFinal(valueNameToken))
    return valueName;

  // There is an error in the decoration
  if (isMidDecorated(valueNameToken))
    errs.collectError(contextCheck, valueNameToken, "Variable declarations cannot be mid-decorated");
  else // was incorrectly final decorated
    checkWrongFinalDecoration(valueNameToken);
  // hoping to improve err msgs for following TrueJ code
  valueName = decorator + variableName(valueName);
  return valueName;
}

@Override
public Void visitInitializedVariable(TLantlrParser.InitializedVariableContext ctx) {
  Token valueNameToken = getStart(ctx.t_initializedVariableDeclaratorId());
  ensureFinalDecorationIsSet(valueNameToken);

  visitChildren(ctx);

  T_expressionContext initializationExpression = ctx.t_variableInitializer().t_expression();
  if (initializationExpression != null)
    checkForConfusingRelationalExpression(initializationExpression);
  return VOIDNULL;
}


@Override
public Void visitT_given(T_givenContext ctx) {
  final boolean oldInLogic = isInLogic;
  isInLogic = true;

  visitChildren(ctx);

  isInLogic = oldInLogic;
  return VOIDNULL;
}

@Override
public Void visitT_finalMeans(T_finalMeansContext ctx) {
  boolean oldInFinalMeans = isInFinalMeans;
  isInFinalMeans = true;

  visitChildren(ctx); // only child is a t_means context

  isInFinalMeans = oldInFinalMeans;
  return VOIDNULL;
}

@Override
public Void visitT_lemma(T_lemmaContext ctx) {
  usingIsInLogicTrue(() -> visitChildren(ctx));
  return VOIDNULL;
}

@Override
public Void visitT_means(T_meansContext ctx) {
  boolean oldInFinalMeans = isInFinalMeans;
  hasOutstandingFinalMeansInBlock = ctx.getStart().getType() == TLantlrLexer.FINAL;
  isInFinalMeans = isInFinalMeans || hasOutstandingFinalMeansInBlock;

  refreshNewMeansValues();

  usingIsInMeansTrue( ()
      -> usingIsInLogicTrue(()
          -> visitChildren(ctx)) );

  currentScope.setLatestMeansStatementLine(getStart(ctx).getLine());
  currentScope.setValuesAvailable(newMeansStatementValues);
  isInFinalMeans = oldInFinalMeans;
  return VOIDNULL;
}

/** Use the Java stack as an implicit stack to temporarily set <code>isInLogic</code> to true  */
private void usingIsInLogicTrue(Runnable function) {
  boolean oldIsInLogic = isInLogic; // save parent condition
  isInLogic = true;                 // push condition
  function.run();                   // apply function using condition
  isInLogic = oldIsInLogic;         // pop back to old condition
}

/** Use the Java stack as an implicit stack to temporarily set <code>isInLogic</code> to true  */
private void usingIsInMeansTrue(Runnable function) {
  boolean oldIsInMeans = isInMeans; // save parent condition
  isInMeans = true;                 // push condition
  function.run();                   // apply function using condition
  isInMeans = oldIsInMeans;         // pop back to old condition
}


@Override
public Void visitT_expression(T_expressionContext ctx) {
  boolean oldInAssignment = isInAssignment;
  isInAssignment = false;

  visitChildren(ctx);

  isInAssignment = oldInAssignment;
  return VOIDNULL;
}

@Override
public Void visitT_identifier(T_identifierContext ctx) {
  final Token idToken = getStart(ctx);
  checkForReservedChars(idToken);
  boolean errorForUndecoratedValueName = checkFinalDecorationSwitch(idToken);
  if (errorForUndecoratedValueName)
    return VOIDNULL;

  if (isInExecutable && isInAssignment)
    checkAssignment(ctx);
  else if (isInExecutable || isInFinalMeans)
    checkReference(ctx);

//TODO: Need to something similar to checkReference for field initialization

  visitChildren(ctx);
  return VOIDNULL;
}


// *************** Helper methods *******************************

public void typeDeclarationVisit(String typeName, ParserRuleContext ctx) {
  // Assumption: field visitor has created a Scope object and loaded it
  // with class fields (and their value names if they were initialized) but it has not
  // filled in the parent scope for that Scope object except for the instance of the top level type.
  // We let the Java compiler check for a single visible top-level type per file.
  final Scope parent = currentScope;

  if (thisIsTheTopLevelType())
    topTypeName = typeName;
  currentScope = typeScope(typeName, ctx, parent);

  visitChildren(ctx);

  currentScope.clearForCodeGeneration();
  currentScope = parent; // pop
}

/** Use the class scope saved from the field Visitor for this rule context or create a new scope for
 * this type. */
private Scope typeScope(String typeName, ParserRuleContext ctx, final Scope parent) {
  final Scope savedClassScopeFromFieldVisitor = scopeMap.get(ctx);
  if (savedClassScopeFromFieldVisitor == null) {
    Scope newScopeForType = new Scope(typeName, parent);
    scopeMap.put(ctx, newScopeForType);
    return newScopeForType;
  } else {
    setParentIfInnerClass(savedClassScopeFromFieldVisitor, parent);
    return savedClassScopeFromFieldVisitor;
  }
}

private void setParentIfInnerClass(Scope possibleInnerClass, Scope parent) {
  if (isInnerClass(possibleInnerClass))
    possibleInnerClass.setParent(parent);
}
private boolean isInnerClass(Scope possibleInnerClass) {
  return possibleInnerClass.parent == null;
}

//@formatter:off
//TODO: The rest of the program has not been checked for preserving readability

/** Check for possible values in a value name that is being assigned a value. */
private void checkAssignment(T_identifierContext ctx) {
  Token valueNameToken = getStart(ctx);
  ensureFinalDecorationIsSet(valueNameToken);
  final VarInfo varInfo = ensureVarInfo(valueNameToken);

  switch (branchState) {
    case InitialBranch:
      checkForAlreadyFinalValue(valueNameToken, varInfo);
      InitialConditionalBranchScope firstScope = getEnclosingInitialScope(valueNameToken);
      checkForPriorDefinitionOfValueName(valueNameToken, varInfo);
      String valName1 = valueName(valueNameToken); // workingValueName(valueNameToken);
      firstScope.setDeligationObligationForEnclosingScopes(valName1, varInfo.getCurrentValueName());
      //checkForCorrectDecorationOfAssignment(valueNameToken);
      defineTheValueNameRegardlessOfErrors(valueNameToken, varInfo);
      break;

    case FollowingBranch:
      checkForAlreadyFinalValue(valueNameToken, varInfo);
      FollowingConditionalBranchScope followingScope = getEnclosingFollowingScope(valueNameToken);
      String valName2 = valueName(valueNameToken); // workingValueName(valueNameToken);
      if ( ! followingScope.getNestedValueNames().remove(valName2))
        errs.collectError(contextCheck, valueNameToken, "Value name "+ valName2
                        +" must also be defined in the initial branch of the conditional statement");
      defineTheValueNameRegardlessOfErrors(valueNameToken, varInfo);
      break;

    case NotInsideConditionalStatement:
      checkForAlreadyFinalValue(valueNameToken, varInfo);
      checkForPriorDefinitionOfValueName(valueNameToken, varInfo);
      //checkForCorrectDecorationOfAssignment(valueNameToken);
      defineTheValueNameRegardlessOfErrors(valueNameToken, varInfo);
      break;
  }
}

private void checkForCorrectDecorationOfAssignment(final Token valueNameToken) {
  if (  isInitialDecorated(valueNameToken)
     || isMidDecorated(valueNameToken)
     || isDecoratedCorrectlyForFinal(valueNameToken))
    return;

  else
    checkWrongFinalDecoration(valueNameToken);
}

/** Search up through ancestor scopes to find the nearest one that is a
 * {@link FollowingConditionalBranchScope}.
 * <p>
 * @precondition There is an enclosing following scope, possibly the currentScope. If there is not
 *               one, generates a runtime cast error.
 * @return closest following scope ancestor */
private FollowingConditionalBranchScope getEnclosingFollowingScope(Token valueNameToken) {
  Scope trialScope = currentScope;
  while( ! (trialScope instanceof FollowingConditionalBranchScope) )
    trialScope = trialScope.getParent();
  FollowingConditionalBranchScope followingScope = (FollowingConditionalBranchScope)trialScope;
  return followingScope;
}

/** Search up through ancestor scopes to find the nearest one that is an
 * {@link InitialConditionalBranchScope}.
 * <p>
 * @precondition There is an enclosing initial scope, possibly the currentScope. Will generate a
 *               runtime cast error if there is not one.
 * @return closest first scope ancestor */
private InitialConditionalBranchScope getEnclosingInitialScope(Token valueNameToken) {
  Scope trialScope = currentScope;
  while( ! (trialScope instanceof InitialConditionalBranchScope) )
    trialScope = getScopeParent(valueNameToken, trialScope);
  return (InitialConditionalBranchScope)trialScope;
}

/**
 * @param valueNameToken
 * @param trialScope
 * @return
 * @throws IllegalStateException
 */
private Scope getScopeParent(Token valueNameToken, Scope trialScope) throws IllegalStateException {
  @Nullable Scope trialScopeParent = trialScope.getParent();
  if (trialScopeParent == null) {
    throw new IllegalStateException(
          "PROGRAMMING ERROR: The branchState variable is "+ branchState
          +", but there is no enclosing InitialConditionalBranchScope "
          + "in the class "+ topTypeName +"for the valuename "+ valueName(valueNameToken)
          +"at line "+ valueNameToken.getLine()
          + " column "+valueNameToken.getCharPositionInLine());
  }
  return trialScopeParent;
}

/** Proceed with valueName definition, even if there were errors, in hopes of generating better
 * error messages for the following code */
private void defineTheValueNameRegardlessOfErrors(Token valueNameToken, VarInfo varInfo) {
  varInfo.defineNewValue(valueNameToken);
  currentScope.makeValueAvailable(valueName(valueNameToken));
}

/** check decorated value name for prior definition */
private void checkForPriorDefinitionOfValueName(Token valueNameToken, VarInfo varInfo) {
  String valueName = valueName(valueNameToken);
  if (varInfo.hasDefinedValue(valueName))
    errs.collectError( contextCheck, valueNameToken, "The value "+ valueName
                      +" has already been defined on line "+ varInfo.lineOf(valueName));
}

private static boolean hasMismatchedFinalDecoration(String newName, String oldName) {
  return isFinalDecorated(newName) && newName.equals(oldName + decorator)
      || isUndecorated(newName)    && oldName.equals(newName + decorator);
}

/**
 * The text of the originally coded value name or, in the case where the name is not valid, a
 * kludged value name to allow checking to continue and catch errors.
 * @deprecated This method will be removed
 */
@Deprecated
private String workingValueName(Token valueNameToken) {
  if (isFinalDecorationRequired() && isUndecorated(valueNameToken)) {
    errs.collectError( contextCheck, valueNameToken,
          valueName(valueNameToken) +" is not a decorated value name so it cannot receive a value");
    return kludgedValueName(valueNameToken);
  } else {
    return valueName(valueNameToken);
  }
}

/**
 * A value name generated purely in hopes of helping to generate additional helpful error messages
 */
static private String kludgedValueName(Token valueNameToken) {
  return decorator + $T$ +  variableName(valueNameToken);
}

/**
 * Check to see if this variable, from the valueNameToken, was already assigned a final value, which
 * is held in the varInfo. If so, we issue an error message but do not stop processing the valueName
 * assignment. Instead we proceed with error checking allowing the new value name in hopes of
 * finding more errors.
 */
private void checkForAlreadyFinalValue(Token valueNameToken, VarInfo varInfo) {
  if (isDecoratedCorrectlyForFinal(valueNameToken))
    // prior final decorations will be caught in checkForPriorDefinitionOfValueName(Token, VarInfo)
    return;


  final String currentValueName = varInfo.getCurrentValueName();
  Integer definitionLine = varInfo.lineOf(currentValueName);
  if (definitionLine == null)
    return;

  if (definitionLine.intValue() == valueNameToken.getLine())
    /* we are in the error condition where the varInfo did not exist,
     * but was created for this currentValueName token as a kludge,
     * and an error message of a different type was already issued */
    return;

  if (currentValueName.equals(valueName(valueNameToken)))
    return;


  if (isInAssignment) {
    if (isAFinalValueName(currentValueName)) {
      errs.collectError( contextCheck, valueNameToken,
          currentValueName +" received a final value at line "+ varInfo.lineOf(currentValueName)
          +", so it cannot receive a new value");
    } else if (isAFinalValueName(valueNameToken)) {
      checkWrongFinalDecoration(valueNameToken);
    }
  }
}


private boolean followingBranchVariable(String valueName) {
  if (branchState == BranchState.FollowingBranch) {
    FollowingConditionalBranchScope followingBranch = (FollowingConditionalBranchScope)currentScope;
    if (followingBranch.getNestedValueNames().contains(valueName))
      return true;
  }

  return false;
}

private VarInfo ensureVarInfo(Token valueNameToken) {
  var OptVar = currentScope.getOptionalExistingVarInfo(variableName(valueNameToken));
  if (OptVar.isPresent())
    return OptVar.get();

  if ( ! isValidUseOfReturn(valueNameToken))
      issueUndefinedVariableError(valueNameToken);
  currentScope.makeValueAvailable(valueName(valueNameToken));
  return kludgeVariableDeclaration(valueNameToken);
}

private boolean isValidUseOfReturn(Token valueNameToken) {
  var valueName = valueName(valueNameToken);
  if (formerReturnDecoration.equals("") || formerReturnDecoration.equals(valueName))
    ; // OK
  else
    errs.collectError(contextCheck, valueNameToken
                     , valueName +" disagrees with former return decoration");
  return isInLogic && valueName.startsWith("return") && isDecoratedCorrectlyForFinal(valueNameToken);
}

private boolean isAlreadyFinallyDecorated(String currentValueName) {
  boolean hasCurrentValue = (currentValueName != null);
  return hasCurrentValue && isFinalDecorated(currentValueName);
}

/**
 * Check the reference to a field or local variable identifier for errors and ensure that the
 * variable and valueName are available to the current scope.
 */
private void checkReference(T_identifierContext ctx) {
  final Token valueNameToken = getStart(ctx);
  String valueName = valueName(valueNameToken);
  if (isAFinalValueName(valueNameToken)) {
    ensureFinalDecorationIsSet(valueNameToken);
    if ( ! isDecoratedCorrectlyForFinal(valueNameToken)) {
      checkWrongFinalDecoration(valueNameToken);
      return;
    }
  }

  if (isInFinalMeans && isMidDecorated(valueNameToken)) {
    errs.collectError( contextCheck, valueNameToken
        , "Mid-decorated value names are not allowed in a final means-statement");
    return;
  }

  var optionalVarInfo = currentScope.getOptionalExistingVarInfo(variableName(valueName));
  VarInfo varInfo;
  if (optionalVarInfo.isEmpty()) {
    recoverFromMissingVariable(valueNameToken);
    currentScope.makeValueAvailable(valueName);
    return;
  }
  varInfo = notNull(optionalVarInfo.get());

  if (varInfo.hasDefinedValue(valueName)) {
    checkForReusingAnOverwrittenValue(valueName, varInfo);
    checkValueNameAvailability(valueNameToken, valueName);
    return;
  }

  if (isAFinalValueName(valueNameToken)) {
    if (isValidFinalFirstReferenceToInitiallyDecoratedField(valueNameToken,varInfo)) {
      currentScope.varToInfoMap.put(variableName(valueName), varInfo);
      currentScope.makeValueAvailable(valueName);
      return;
    } else {
      checkForAlreadyFinalValue(valueNameToken, varInfo);
      return;
    }
  }

  issueUndefinedValueNameMsg(valueNameToken, varInfo);
}

private boolean isValidFinalFirstReferenceToInitiallyDecoratedField( Token valueNameToken
                                                                   , VarInfo varInfo) {
  String valueName = valueName(valueNameToken);
  return isDecoratedCorrectlyForFinal(valueNameToken)
      && varInfo.hasClassScope()
      && isInitialDecorated(varInfo.getCurrentValueName())
      ;
}

private void checkValueNameAvailability(Token valueNameToken, String valueName) {
  boolean isAvailableInCurrentScope = currentScope.hasAvailable(valueName);
  //TODO: Try eliminating last disjunct from the following if statement
  if ( ! isAvailableInCurrentScope || (isInMeans && isAFinalValueName(valueNameToken))) {
    /*TODO: search up the Scope hierarchy to see if it was eclipsed in a higher scope
     *      Then go back to the next lower one to find the line number of the means statement */
    int latestMeansLine = currentScope.latestMeansStatementLine();
    if (latestMeansLine == 0) {
      var variableInfo = currentScope.getOptionalExistingVarInfo(variableName(valueName));
      if (variableInfo.isPresent()) {
        var varInfo = notNull(variableInfo.get());
        var currentValueName = varInfo.getCurrentValueName();
        if ( ! currentValueName.equals(valueName)) {
//          if (isAFinalValueName(valueNameToken) && isAFinalValueName(currentValueName)) {
//            checkWrongFinalDecoration(valueNameToken);
//            return;
//          } else {
          var msg = "The value name "+ valueName + " is not available in this scope"
              +" (variable "+ variableName(valueName)
              +" has the value named "+ currentValueName +" at this point)";
          errs.collectError( contextCheck, valueNameToken, msg);
        }
      }
    } else if ( ! isAvailableInCurrentScope) {
      var msg = "The value name "+ valueName + " is not available in this scope "
          +"(perhaps it needs to be included in the means statement at line "+ latestMeansLine +")";
      errs.collectError( contextCheck, valueNameToken, msg);
    }
  }

  if (isInMeans && isAvailableInCurrentScope)
    newMeansStatementValues.add(valueName);
}

private void checkForReusingAnOverwrittenValue(String valueName, VarInfo varInfo) {
  if ( reusingAPreviousValueName(valueName, varInfo)) {
      if (isInExecutable && ! isInLogic) {
        varInfo.reusedValueNames.add(valueName);
      }
  }
}

private boolean reusingAPreviousValueName(String valueName, VarInfo varInfo) {
  return ! valueName.equals(varInfo.getCurrentValueName());
}

/**
 * Issue the error message that is needed for the use of a value name that has not been defined. We
 * have the variable's varInfo, but we don't have the value name that is being used.
 * @deprecated Use issueUndefinedValueNameMsg(valueNameToken, varInfo) instead
 */
@Deprecated
private void errorAndRecoveryForReferenceToUndefinedValue(Token valueNameToken, VarInfo varInfo) {
  String valueName;
  switch (valueNameToken.getType()) {
    case PreValueName:
    case MidValueName:
      issueUndefinedValueNameMsg(valueNameToken, varInfo);
      break;

    case PostValueName:
    case UndecoratedIdentifier:
      ensureFinalDecorationIsSet(valueNameToken);
      valueName = valueName(valueNameToken);
//      if (hasMismatchedFinalDecoration(valueName, varInfo.getCurrentValueName()))
//         checkWrongFinalDecoration(valueNameToken);
//      else
      issueUndefinedValueNameMsg(valueNameToken, varInfo);
      break;

    default:
      String msg = "PROGRAMMING ERROR: "
                 + "in ContextCheckVisitor: method "
                 + "errorAndRecoveryForReferenceToUndefinedValue(valueNameToken,  varInfo), "
                 + "value name "+ valueName(valueNameToken);
      errs.collectError(contextCheck, valueNameToken, msg);
      System.err.println("\n\n**************** PROGRAMMING ERROR ****************\n");
      System.err.println(errs.toString());
      System.err.println("\n***************************************************\n");
      System.exit(1);
  }

  defineTheValueNameRegardlessOfErrors(valueNameToken, varInfo);
}

private void checkWrongFinalDecoration(Token valueNameToken) {
  if ( ! isDecoratedCorrectlyForFinal(valueNameToken)) {

    String valueName = valueName(valueNameToken);
    var varName = variableName(valueName);
    if (currentScope.isVariableDefinedInThisScope(varName)) {
      VarInfo varInfo = notNull(currentScope.varToInfoMap.get(varName));
      String currentName = varInfo.getCurrentValueName();
      if (isFinalDecorated(currentName) && ! valueName.equals(currentName)) {
        errs.collectError( contextCheck, valueNameToken
            , "A different final decoration "+ currentName
            +" was used at line "+ varInfo.getLineWhereDeclared());
        return;
      }
    }

    // if any of the above conditions is false
    errs.collectError( contextCheck, valueNameToken
        , "A different decoration for final values was used in line "+ finalDecorationLine()
        +" for the final value name "+ finalDecorationValue());
  }
}

private void issueUndefinedValueNameMsg(Token valueNameToken, VarInfo varInfo) {
  var valueName = valueName(valueNameToken);
//  if (isAFinalValueName(valueName))
//    checkWrongFinalDecoration(valueNameToken);
//  else
  errs.collectError( contextCheck, valueNameToken
      , "Value "+ valueName
        +" has not been defined for the variable "+ variableName(valueNameToken)
        +" that was declared at line "+ varInfo.getLineWhereDeclared());
}

/** We generate the missing VarInfo and make sure that it has some current value decoration, hoping
 * that this will result in generating better error messages in the following code.
 * <p>
 * ASSUMES: the variable for the valueNameToken has not been declared yet
 *  @return A dummy VarInfo for the non-existent variable
 */
private VarInfo recoverFromMissingVariable(Token valueNameToken) {
  if (isValidUseOfReturn(valueNameToken))
    return kludgeVariableDeclaration(valueNameToken);

//  if (isDecoratedCorrectlyForFinal(valueNameToken))
  issueUndefinedVariableError(valueNameToken);
//  else
//    checkWrongFinalDecoration(valueNameToken);
  return kludgeVariableDeclaration(valueNameToken);
}

private void issueUndefinedVariableError(Token valueNameToken) {
  errs.collectError( contextCheck, valueNameToken,
        "Variable "+variableName(valueNameToken)+" has not been defined in this scope");
}

  private VarInfo kludgeVariableDeclaration(Token valueNameToken) {
  return currentScope.declareNewVarNameWithValueName(valueNameToken, "NoTypeForUndeclaredReference")
                     .get();
}

@SuppressWarnings("null")
String checkedText(TerminalNode id) {
  checkForReservedChars(id.getSymbol());
  return id.getText();
}

private void checkForReservedChars(final Token idToken) {
  final String id = valueName(idToken);
  if (id.contains($T$)) {
    errs.collectError(contextCheck, idToken , invalidCharsMsg);
  }
}

final public static boolean isDecoratedCorrectlyForFinal(Token valueToken) {
  ensureFinalDecorationIsSet(valueToken);
  return (isFinalDecorationProhibited() && TUtil.isUndecorated(valueToken))
      || (isFinalDecorationRequired()   && TUtil.isFinalDecorated(valueToken));
}

@SuppressWarnings("null")
private Void visitContextChildren(T_fieldDeclaratorContext ctx) {
  return visitChildren(ctx);
}

@SuppressWarnings("null")
private static String asString(TerminalNode node) {
  return node.toString();
}

@SuppressWarnings("null")
private static Token getStart(ParserRuleContext ctx) {
  return ctx.getStart();
}

@SuppressWarnings("null")
private static String valueName(Token valueNameToken) {
  return valueNameToken.getText();
}

/**
 * Juggle the status of an object from @Nullable to @NonNull for an object that is known to be
 * non-null. The programmer must ensure that the object is guaranteed by other code to be non-null.
 * Instead of using this method, it is much safer to check for <code>null</code> and throw an
 * exception if you made a mistake. But if you are confident, using this is more elegant than a
 * <code>@SuppressWarnings("null")</code> on a whole method. Since this method is private and
 * does not affect runtime state, it compiles away to almost nothing.
 */
@SuppressWarnings("null")
private static <T> @NonNull T notNull(@Nullable T item) {
  return (@NonNull T)item;
}


//TODO include rest of visit methods for value related code

} // end class FieldVisitor
